# -*- coding: utf-8 -*-
"""Copy of Matplotlib.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bf2AAOvum7nobjLs1LpIIKTvzDn3TNZ6

# ***Основы работы с Matplotlib***


---

[*Официальная документация*](https://matplotlib.org/)

**Matplotlib** является основополагающей библиотекой по визуализации данных в Python.

---



Эту библиотеку создал John Hunter, чтобы реализовать что-то похожее на визуализацию MatLab в Python. 
Библиотека позволяет создавать двумерные и трёхмерные графики.

***Основые преимущества Matplotlib следующие:***

*   Достаточно просто начать создавать простые графики
*   Возможность создавать свои собственные текстовые надписи на графиках
*   Возможность настраивать любые элементы на графике
*   Экспорт результатов в разных форматах, с высоким качеством
*   В целом многое можно настроить

# ***Установка***

---
Для эффективного изучения необходимо выполнить следующие пункты:

Установить интерпретатор Python

Установить PyCharm (для студентов доступны бесплатные версии Professional Edition) или другую IDE

Установка дистрибутива Anaconda (по желанию)

Также можно использовать Google Colaboratory или Jupiter Notebook в этом случае вам не придется проделывать шаги 1-3 :)

*Для установки пакета matplotlib воспользуйтесь следующими командами:*

conda install matplotlib

или

pip install matplotlib

# ***Построение графика на основе двух массивов NumPy***
"""

import matplotlib.pyplot as plt
import numpy as np

x = np.arange(0,10)
y = x**2

plt.plot(x, y) 

plt.xlabel('Название оси X')
plt.ylabel('Название оси Y')
plt.title('Название графика')
plt.show() # Опциональная команда для студентов,
           # работающих в jupiter notebook/google colab, необходима при работе в IDE

"""# ***Редактирование параметров***

Для кастомизации графиков мы можем использовать следующие команды:


*   Чтобы задать названия осей X,Y


  1.   plt.xlabel('Ось X')
  2.   plt.ylabel('Ось Y')


*   Чтобы задать название осей графика используйте

    plt.title('Название графика')



*   Чтобы установить ограничения для оси используйте 

  1.   plt.xlim(xmin,xmax) 
  2.   plt.ylim(ymin, ymax) 








"""

plt.plot(x, y) 
plt.xlabel('Название оси X')
plt.ylabel('Название оси Y')
plt.title('Название графика')
plt.xlim(-2,10) 
plt.ylim(0, 40) 
plt.show()

"""# Экспорт графика
Для получения подробного описания запустите ячейку
"""

help(plt.savefig)

"""# Сохранение графика 
Для сохранения построенного графика используйте команду plt.savefig('имя_файла.формат')
 
"""

plt.plot(x,y)
plt.savefig('example_1.svg')

"""# ***Объектно-ориентированный подход Matplotlib***

Рассмотрим более формальный подход к объектно-ориентированному API для Matplotlib. Мы будем создавать экземпляры объектов figure, и затем обращаться к атрибутам и методам этих объектов.
Такой подход более удобен в случаях, когда на одном рисунке должны находиться несколько графиков.
"""

import matplotlib.pyplot as plt
import numpy as np

a = np.linspace(0,10,11)
b = 2*a +7 

# Создаём пустое поле для рисования (canvas/figure)
fig = plt.figure()

# Добавляем набор осей
axes = fig.add_axes([0, 0, 1, 1]) # left, bottom, width, height (диапазон от 0 до 1)

# Наносим график на этот набор осей
axes.plot(a, b)

plt.show()

"""# Добавляем ещё один набор осей
Для одного объекта figure можно добавить не только один набор осей, но и несколько таких наборов осей - с другими размерами и расположением. И далее мы можем рисовать графики отдельно на каждом из наборов осей.
"""

import matplotlib.pyplot as plt
import numpy as np

x = np.arange(0,10)
y = x**2

fig = plt.figure()

axes1 = fig.add_axes([0, 0, 1, 1])         # Большой набор осей
axes2 = fig.add_axes([0.2, 0.2, 0.5, 0.5]) # Маленький набор осей

# Рисуем график на бОльшем наборе осей - Axes 1
axes1.plot(x, y)

# С помощью методов set_ указываем атрибуты для осей
axes1.set_xlabel('Ось X')
axes1.set_ylabel('Ось Y')
axes1.set_title('Большой график')

# Рисуем график на меньшем наборе осей - Axes 2
axes2.plot(a,b)
axes2.set_title('Маленький график');

"""# **Подвинем меньший набор осей и поменяем его параметры**

---



"""

import matplotlib.pyplot as plt
import numpy as np

x = np.arange(0,10)
y = x**2

fig = plt.figure()

axes1 = fig.add_axes([0, 0, 1, 1])           # Большой набор осей
axes2 = fig.add_axes([0.2, 0.5, 0.25, 0.25]) # Маленький набор осей

# Рисуем график на бОльшем наборе осей - Axes 1
axes1.plot(x,y)

# С помощью методов set_ указываем атрибуты для осей
axes1.set_xlabel('Ось X')
axes1.set_ylabel('Ось Y')
axes1.set_title('Большой график')

# Рисуем график на меньшем наборе осей - Axes 2
axes2.plot(x,y)
axes2.set_xlim(0,5)
axes2.set_ylim(0,10)
axes2.set_xlabel('X')
axes2.set_ylabel('Y')
axes2.set_title('Смещенный график');

"""# ***Аттрибуты объекта Figure***


---


"""

help(plt.figure)

fig = plt.figure(figsize=(12,8),dpi=100)

axes1 = fig.add_axes([0, 0, 1, 1])

axes1.plot(x,y)

"""# ***Экспорт объекта Figure***


---





"""

fig = plt.figure()

axes1 = fig.add_axes([0, 0, 1, 1])

axes1.plot(a,b)
axes1.set_xlabel('Ось X')
axes1.set_ylabel('Ось Y')
axes1.set_title('Большой график')

# bbox_inches ='tight' автоматически подбирает правильный прямоугольник вокруг графика

fig.savefig('figure.png',bbox_inches='tight')

"""#Размещение графика за пределами основного 

---


"""

fig = plt.figure(figsize=(12,8))

axes1 = fig.add_axes([0, 0, 1, 1]) # Рисуем график на бОльшем наборе осей - Axes 1
axes2 = fig.add_axes([1, 1, 0.25, 0.25]) # Набор осей в верхнем правом углу!


# Рисуем график на бОльшем наборе осей - Axes 1
axes1.set_xlabel('Ось X')
axes1.set_ylabel('Ось Y')
axes1.set_title('Большой график')
axes1.plot(x,y)

# Рисуем график на меньшем наборе осей - Axes 2
axes2.set_xlabel('Ось A')
axes2.set_ylabel('Ось B')
axes2.set_title('Маленький график')
axes2.plot(a,b)

fig.savefig('test.png',bbox_inches='tight')

"""# ***Размещение нескольких графиков в рамках одного изображения***


---



Метод

> plt.subplots()
 
позволяет автоматически разместить несколько наборов осей рядом друг с другом.
"""

# Очень похоже на plt.figure(), но здесь мы используем 
# распаковку кортежа для получаения значений fig и axes

fig, axes = plt.subplots()

# Далее с помощью объекта axes указываем значения для атрибутов
axes.plot(x, y, 'r')
axes.set_xlabel('x')
axes.set_ylabel('y')
axes.set_title('Название графика');

"""## Добавляем строки и колонки"""

import matplotlib.pyplot as plt
import numpy as np

fig, axes = plt.subplots(nrows=2, ncols=3)

"""## Рисуем графики на объекте axes"""

fig,axes = plt.subplots(nrows=1,ncols=2)

axes[0].plot(a,b)
axes[1].plot(x,y)

fig, axes = plt.subplots(nrows=1,ncols=2)


for index, axe in enumerate(axes):
  if index == 0:
    axe.plot(x,y)
  if index == 1:
    axe.plot(a,b)

"""Частая проблема в matplotlib - это наложение графиков друг на друга. 
Чтобы решить эту проблему, можно использовать методы fig.tight_layout() или plt.tight_layout() для автоматической подгонки осей, чтобы не было пересечений:
"""

# Обратите внимание! В данном случае на выходе получаем двумерный массив
fig,axes = plt.subplots(nrows=2,ncols=2)

axes[0][0].plot(a,b)
axes[1][1].plot(x,y)  

plt.tight_layout()

"""# ***Параметры subplots()***
Так как у нас есть два объекта - Figure и axes. Мы можем редактировать свойства этих объектов.


---


"""

fig,axes = plt.subplots(nrows=2,ncols=2,figsize=(12,8))

# СНАЧАЛА УСТАНАВЛИВАЕМ ПАРАМЕТРЫ AXES

# Параметры на уровне объекта axes 
axes[0][0].plot(a,b)
axes[0][0].set_title('0 0 Заголовок')


axes[1][1].plot(x,y)
axes[1][1].set_title('1 1 Заголовок')
axes[1][1].set_xlabel('1 1 Ось X')

axes[0][1].plot(y,x)
axes[1][0].plot(b,a)

# ДАЛЕЕ УСТАНАВЛИВАЕМ ОБЩИЕ ПАРАМЕТРЫ FIGURE

# Параметры на уровне объекта Figure
fig.suptitle("Заголовок для объекта Figure",fontsize=16)


plt.show()

"""# ***Ручное указание размеров в subplots()***

---


> .subplots_adjust

позволяет указывать размеры вручную.

Более полное описание можно почитать [здесь:](https://matplotlib.org/3.2.2/api/_as_gen/matplotlib.pyplot.subplots_adjust.html)

**Примеры из этой статьи:**

left = 0.125 # отступ слева

right = 0.9 # отступ справа

bottom = 0.1 # отступ снизу

top = 0.9 # отступ сверху

wspace = 0.2 # ширина между отдельными наборами осей, измеряемая как доля от средней ширины осей

hspace = 0.2 # высота между наборами осей, измеряемая как доля от средней высоты осей



"""

fig,axes = plt.subplots(nrows=2,ncols=2,figsize=(12,8))

# Параметры на уровне axes 
axes[0][0].plot(a,b)
axes[1][1].plot(x,y)
axes[0][1].plot(y,x)
axes[1][0].plot(b,a)

# С помощью left,right,top, bottom можно двигать наборы осей
# С помощью wspace,hspace можно регулировать расстояния между наборами осей
fig.subplots_adjust(left=None,
    bottom=None,
    right=None,
    top=None,
    wspace=0.9,
    hspace=0.1,)

plt.show()

"""# **Экспорт plt.subplots()**"""

# Обратите внимание! Здесь мы получаем двумерный массив
fig,axes = plt.subplots(nrows=2,ncols=2,figsize=(12,8))

axes[0][0].plot(a,b)
axes[1][1].plot(x,y)
axes[0][1].plot(y,x)
axes[1][0].plot(b,a)

fig.savefig('subplots.png',bbox_inches='tight')

plt.show()

"""# ***Стилизация графиков***

---

С помощью именованного параметра label=“label text” можно указать названия для тех или иных линий на графике. Далее с помощью метода legend, уже без параметров, можно добавить легенду.

Обратите внимание, что легенда может потенциально загородить собой часть линий!
В методе legend есть опциональный именованный параметр loc, с помощью которого можно указать, где именно рисовать легенду. Возможные значения параметра loc - это числа, каждое из которых соответствует определённому месту на графике.
"""

fig = plt.figure()

ax = fig.add_axes([0,0,1,1])

import matplotlib.pyplot as plt
import numpy as np

x = np.arange(0,10)
y = x**2

ax.plot(x, x**2, label="x**2")
ax.plot(x, x**3, label="x**3")

# Задать сетку для графика
ax.grid(True)

ax.legend(loc=0) # matplotlib сам выбирает оптимальное местоположение

fig = plt.figure()

ax = fig.add_axes([0,0,1,1])

import matplotlib.pyplot as plt
import numpy as np

x = np.arange(0,10)
y = x**2

ax.plot(x, x**2, label="x**2")
ax.plot(x, x**3, label="x**3")

# Задать сетку для графика
ax.grid(True)

# Задаем вручную
ax.legend(loc=(0.4,0.5)) # задаём вручную

"""# Настройка сетки для графика"""

fig = plt.figure()

ax = fig.add_axes([0,0,1,1]).grid

help(ax)

"""# ***Цвета, ширина линий и типы линий***


---


Matplotlib предоставляет много возможностей по настройке цветов, ширины линий и типов линий.

Для этого можно использовать базовый синтаксис, похожий на MATLAB. 

# **Цвета с использованием синтаксиса MatLab**


---


В matplotlib можно задавать цвета линий и других графических элементов разными способами. 
Первый способ - похожий на MATLAB синтаксис, в котором 'b' означает blue, 'g' означает green и так далее. 
Также поддерживается MATLAB API для выбора стиля линий: например, ‘b.-’ означает цвет blue и линия с точками:

"""

# Цвета и стили с применением синтаксиса MATLAB 
fig, ax = plt.subplots()
ax.plot(x, x**2, 'b.-') # blue line with dots
ax.plot(x, x**3, 'g--') # green dashed line

# Ширина линий
# Для изменения ширины линии есть именованный параметр linewidth или lw.

fig, ax = plt.subplots(figsize=(12,6))

# Пишем linewidth или lw
ax.plot(x, x-1, color="red", linewidth=0.25)
ax.plot(x, x-2, color="red", lw=0.50)
ax.plot(x, x-3, color="red", lw=1)
ax.plot(x, x-4, color="red", lw=10)

# Стили линий
# Различных вариантов много, вот примеры:

# Возможные варианты для linestype:  ‘--‘, ‘–’, ‘-.’, ‘:’, ‘steps’
fig, ax = plt.subplots(figsize=(12,6))

ax.plot(x, x-1, color="green", lw=3, linestyle='-') # solid
ax.plot(x, x-2, color="green", lw=3, ls='-.') # dash and dot
ax.plot(x, x-3, color="green", lw=3, ls=':') # dots
ax.plot(x, x-4, color="green", lw=3, ls='--') # dashes



"""# ***Маркеры***
По сути мы раньше всегда рисовали точки, и matplotlib автоматически соединял эти точки с помощью линий. 
Давайте посмотрим, как мы можем нарисовать маркеры в каждой из этих точек.
Стили маркеров
Большой список различных типов маркеров можно найти [здесь](https://matplotlib.org/3.2.2/api/markers_api.html): 
"""

fig, ax = plt.subplots(figsize=(12,6))

# Параметр marker содержит строковый код
# Параметр markersize или ms задаёт размер

ax.plot(x, x-1,marker='*',markersize=20)
ax.plot(x, x-2,marker='o',ms=20) #ms = markersize
ax.plot(x, x-3,marker='1',ms=20,lw=0) # указываем linewidth=0, чтобы увидеть только маркеры
ax.plot(x, x-4,marker='o',ms=20)

"""# ***Различные края маркеров, ширина, размер и стиль***"""

fig, ax = plt.subplots(figsize=(12,6))
x = np.arange(0,10)
y = x**2


# размер и цвет маркеров
ax.plot(x, x, color="black", lw=1, ls='-', marker='s', markersize=20, 
        markerfacecolor="red", markeredgewidth=8, markeredgecolor="blue");

"""# ***Сетка - Axis grid***

---

Сетку по осям можно включать и выключать с помощью метода grid объекта axis. В этом методе доступны те же именованные параметры, что и в методе plot:

"""

fig, axes = plt.subplots(1, 2, figsize=(10,3))
x = np.arange(0,10)
y = x**2


# default grid appearance
axes[0].plot(x, x**2, x, x**3, lw=2)
axes[0].grid(True)

# custom grid appearance
axes[1].plot(x, x**2, x, x**3, lw=2)
axes[1].grid(color='b', alpha=0.5, linestyle='dashed', linewidth=0.5)

"""# ***Трёхмерные графики***

---
Чтобы использовать 3D-графику в matplotlib, нам нужно сначала создать экземпляр класса `Axes3D`.

Трёхмерные оси можно добавлять в объект figure точно так же, как и двумерные оси. 

Или, что более удобно, можно передавать именованный параметр `projection='3d'` в методы `add_axes` или `add_subplot`.

"""

from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import numpy as np


n_radii = 8
n_angles = 36

# Make radii and angles spaces (radius r=0 omitted to eliminate duplication).
radii = np.linspace(0.125, 1.0, n_radii)
angles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)

# Repeat all angles for each radius.
angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)

# Convert polar (radii, angles) coords to cartesian (x, y) coords.
# (0, 0) is manually added at this stage,  so there will be no duplicate
# points in the (x, y) plane.
x = np.append(0, (radii*np.cos(angles)).flatten())
y = np.append(0, (radii*np.sin(angles)).flatten())

# Compute z to make the pringle surface.
z = np.sin(-x*y)

fig = plt.figure()
ax = fig.gca(projection='3d')

ax.plot_trisurf(x, y, z, linewidth=0.2, antialiased=True)

plt.show()

"""# ***Построение столбчатых диаграмм*** 

---
Для визуализации категориальных данных хорошо подходят столбчатые диаграммы. Для их построения используются функции:

bar() – для построения вертикальной диаграммы

barh() – для построения горизонтальной диаграммы.

---

**Основные параметры:**

x: набор величин
x координаты столбцов
height : скалярная величина или набор величин

Высоты столбцов
width: скалярная величина, массив или optional

Ширина столбцов
bottom: скалярная величина, массив или optional
y координата базы

align : {‘center’, ‘edge’}, optional, значение по умолчанию: ‘center’

Выравнивание по координате x.

**Дополнительные параметры:**

color: скалярная величина, массив или optional
Цвет столбцов диаграммы

edgecolor: скалярная величина, массив или optional
Цвет границы столбцов

linewidth: скалярная величина, массив или optional
Ширина границы

tick_label: str, массив или optional
Метки для столбца

xerr, yerr: скалярная величина, массив размера shape(N,) или shape(2,N) или optional
Величина ошибки для графика. Выставленное значение удаляется/прибавляется к верхней (правой – для горизонтального графика) границе. Может принимать следующие значения:
скаляр: симметрично +/- для всех баров

shape(N,): симметрично +/- для каждого бара
shape(2,N): выборочного – и + для каждого бара. Первая строка содержит нижние значения ошибок, вторая строка – верхние.
None: не отображать значения ошибок. Это значение используется по умолчанию.
ecolor: скалярная величина, массив или optional, значение по умолчанию: ‘black’
Цвет линии ошибки.
log: bool, optional, значение по умолчанию: False

Включение логарифмического масштаба для оси y
orientation : {‘vertical’, ‘horizontal’}, optional
Ориентация: вертикальная или горизонтальная.

"""

import numpy as np
import matplotlib.pyplot as plt

np.random.seed(123)
groups = [f"P{i}" for i in range(7)]

counts = np.random.randint(3, 10, len(groups))
plt.bar(groups, counts)

"""# **Компромисс между смещением и дисперсией**

---


"""

variance = [1, 2, 4, 8, 16, 32, 64, 128, 256] # дисперсия 
bias_squared = [256, 128, 64, 32, 16, 8, 4, 2, 1] # квадрат смещения
# суммарная ошибка
total_error =[x + y for x, y in zip(variance, bias_squared) ] 
xs = [i for i, _ in enumerate(variance)]

# мегод plt.plot можно вызывать много раз,
# чтобы показать несколько графиков на одной и той же диаграмме: # зеленая сплошная линия
plt.plot(xs, variance, 'g-',label='дисперсия')
# красная штрихпунктирная
plt.plot (xs, bias_squared, 'r-.', label=' смещение^2')
# синяя пунктирная
plt.plot (xs, total_error, 'b:', label='суммарная ошибка')
# если для каждой линии задано название label, # то легенда будег показана автоматически,
# loc-9 означает "наверху посередине"
plt.legend(loc=9)
plt.xlabel("Сложность модели")
plt.title("Компромисс между смещением и дисперсией" ) 
plt.show()

"""# ***Практическое задание***

---
# Task 1

С помощью объектно-ориентированного подхода создайте 4 графика (разместите их в рамках одного изображения)
установите сетку и легенду для каждого из графиков.
для первых 2 графиков(графики А и B) используйте рандомно сгенерированные массивы Numpy в качестве данных для осей X и Y. 
Графики С и D должны демонстрировать обратную пропорциональность графикам A и B.



---
# Task 2


Важно уметь отобразить данные уравнения на графике. 
В качестве уравнения мы будем использовать очень известное уравнение: **$$E=mc^2$$**
 
С помощью Ваших знаний Numpy создайте два массива: 


E и m:
значения m - это 11 равноотстоящих друг от друга чисел от 0 граммов до 10 граммов
значения E должны быть равны энергии для этих масс.

Вам нужно будет указать значение для c, приведя его в нужные единицы измерения - в метрах в секунду, построить график, где ось X - масса в граммах, ось Y - энергия в Дж.
Также добавьте сетку для графика и сохраните изображение в формате svg.

---
# Task 3
По ссылке ниже находятся результаты эксперимента для определения оценки плотности и частоты столкновений электронов в плазме газового разряда

https://docs.google.com/spreadsheets/d/1uhfKZNivSHeENrM4Go8n0KMs9jYQeLKtPJTju7HqQXg/edit#gid=777647444

Назвать график, обозначить оси, рассчитать среднеквадратичное отклонение, построить график и сохранить его в формате jpeg.





"""